# üéÆ Valorant Core Engine | Simulation Backend

![Java](https://img.shields.io/badge/Java-ED8B00?style=for-the-badge&logo=openjdk&logoColor=white)
![Status](https://img.shields.io/badge/Versi√≥n-1.0_Estable-green?style=for-the-badge)
![UD3](https://img.shields.io/badge/Evaluaci√≥n-UD3_Estructuras_Control-blue?style=for-the-badge)

Este proyecto es un simulador t√°ctico de backend basado en el universo de **Valorant**. La aplicaci√≥n gestiona de forma integral la l√≥gica de combate, la jerarqu√≠a de personajes y el c√°lculo de da√±o bal√≠stico din√°mico, cumpliendo estrictamente con los requisitos de programaci√≥n orientada a objetos y gesti√≥n de colecciones.

---

## üèóÔ∏è Arquitectura del Sistema

El proyecto est√° organizado en dos paquetes estrat√©gicos para garantizar el desacoplamiento:

### 1. `com.valorant.core` (Entidades de Juego)
Contiene la definici√≥n de los objetos del dominio. Se utiliza **Herencia** para especializar comportamientos.

* **Jerarqu√≠a de Agentes:**
    * `Agente` (Padre): Base con l√≥gica de comparaci√≥n `equals/hashCode`.
    * `Duelista`, `Centinela`, `Controlador` (Hijas): Implementan atributos √∫nicos como multiplicadores de velocidad o gesti√≥n de trampas.
* **Jerarqu√≠a de Armas:**
    * `Arma` (Padre): Atributos de capacidad y da√±o base.
    * `Fusil`, `Francotirador`, `Subfusil` (Hijas): Implementan el **Damage Falloff** (ca√≠da de da√±o por distancia) y modos de disparo espec√≠ficos.

### 2. `com.valorant.engine` (L√≥gica y Gesti√≥n)
Donde reside la inteligencia del simulador y el manejo de datos complejos.

* **`Arsenal`:** Sistema CRUD gestionado por un `HashMap<String, Arma>`.
* **`Squad`:** Control de escuadrones mediante `ArrayList<Agente>` y logs de historial.
* **`CombateLog`:** Motor de c√°lculo de impactos con l√≥gica de `HashMap<Agente, Integer>`.
* **`Partida`:** Orquestador principal que utiliza `HashSet<String>` para el control de jugadores vivos en tiempo real.

---

## üõ†Ô∏è Especificaciones T√©cnicas (UD3)

Para garantizar la m√°xima nota, el proyecto implementa las siguientes estructuras de control y datos:

### üìä Gesti√≥n de Colecciones
| Estructura | Implementaci√≥n | Prop√≥sito |
| :--- | :--- | :--- |
| **HashMap** | `catalogoArmas` | Acceso $O(1)$ a las armas por nombre. |
| **HashMap** | `danoRecibido` | Registro acumulativo de da√±o por Agente. |
| **HashSet** | `jugadoresVivos` | Gesti√≥n eficiente de estados de eliminaci√≥n. |
| **ArrayList** | `miembros`, `historial` | Gesti√≥n secuencial de equipo y eventos. |

### ‚öôÔ∏è L√≥gica de Control
* **C√°lculo Din√°mico:** El da√±o se procesa mediante condicionales anidados en `CombateLog`.
    $$D_{final} = (D_{base} \cdot M_{distancia}) \cdot M_{zona}$$
* **Bucle de Simulaci√≥n:** Un ciclo `while` en `Partida` controla el flujo de las 13 rondas reglamentarias.
* **Filtrado Eficiente:** Uso de bucles `for-each` para b√∫squeda de armas por umbral de da√±o y aplicaci√≥n de da√±o global por explosi√≥n.

---

## üìã Requisitos de Implementaci√≥n

Cada clase en este proyecto incluye de forma obligatoria:
1.  **Atributos:** M√≠nimo 4 atributos por clase (incluyendo Tipos Primitivos, String y Enums).
2.  **Encapsulamiento:** Getters, Setters y Constructores (Vac√≠o y Completo).
3.  **M√©todos Object:** Sobrescritura de `toString`, `equals` y `hashCode`.
4.  **Enums:** Uso de enumerados para `TipoAgente` y `ZonaCuerpo`.

---

## üöÄ Ejecuci√≥n

La clase `Main` (en la ra√≠z) instancia el ecosistema completo, simulando:
1.  La creaci√≥n de un **Arsenal** completo.
2.  La formaci√≥n de un **Squad** (con validaci√≥n de composici√≥n t√°ctica).
3.  Una secuencia de combate con registro de logs y resumen final de bajas.

---
> **Nota Acad√©mica:** Este proyecto ha sido dise√±ado para demostrar habilidades avanzadas en el manejo de herencia, polimorfismo y estructuras de datos din√°micas en Java.